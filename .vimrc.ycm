" Tarrex's vimrc
"       ------ Enjoy vim, enjoy coding.

" ============> General <============

let s:vimdir = $HOME . '/.vim'  " vim config directory

if &compatible
    set nocompatible            " be iMproved, required
endif

syntax on                       " syntax highlighting
filetype indent plugin on       " filetype detection on

set number                      " print the line number in front of each lin
set ruler                       " show the line and column number of the cursor position, separated by a comma
set wrap                        " wrap lines longer than the width of the window

let s:bytes = getfsize(@%)
if s:bytes < 10 * 1024 * 1024   " 10MB
    set cursorline              " show underline for the cursor's line
    " set cursorcolumn            " show column line for the cursor's column
else
    set nocursorline
    set nocursorcolumn
endif

set expandtab                   " covert tabs to spaces, insert real tab by ctrl-v<tab> if you want
set shiftround                  " round indent to multiple of 'shiftwidth'
set shiftwidth=4                " number of spaces to use for each step of (auto)indent
set tabstop=4                   " number of spaces that a <tab> in the file counts for
set softtabstop=4               " number of spaces that a <tab> counts for while performing editing operations
set smarttab                    " be smart when use tabs

set autoindent                  " copy indent from current line when starting a new line
set cindent                     " enables automatic c program indenting
set breakindent                 " every wrapped line will continue visually indented

if has('multi_byte')
    set fileencodings=ucs-bom,utf-8,gbk,gb18030,big5,euc-jp,latin1 " list of character encodings considered when starting to edit an existing file
    set encoding=utf-8          " the character encoding used inside vim
    set fileencoding=utf-8      " the character encoding for the file of this buffer
endif
set fileformat=unix             " gives the <eol> of the current buffer
set fileformats=unix,dos,mac    " gives the <eol> formats of editing a new buffer or reading a file

set ambiwidth=double            " use twice the width of ASCII characters for East Asian Width Class Ambiguous
set delcombine                  " delete each combining character on its own
set backspace=indent,eol,start  " the working of <bs>, <del>, ctrl-w and ctrl-u in insert mode

set hidden                      " allow buffers to have changes without being displayed
set autoread                    " auto load the file when changed outside vim
set autowrite                   " auto write file when building or switching
set lazyredraw                  " don't redraw while executing macros, registers and other commands that have not been typed
set report=0                    " always reporting number of lines changed
set ttyfast                     " indicates a fast terminal connection
set ttimeout                    " timeout for key codes
set ttimeoutlen=100             " wait up to 100ms after esc for special key

set ignorecase                  " ignore case in search patterns.
set smartcase                   " override the 'ignorecase' option if the search pattern contains upper case characters
set incsearch                   " real time show the search case
set hlsearch                    " highlight all search pattern results

set splitbelow                  " horizontally split below
set splitright                  " vertically split to the right
set noequalalways               " all the windows are automatically made the same size after splitting or closing a window

set cedit=<c-y>                 " the key used in command-line mode to open the command-line window
set pastetoggle=<F4>            " set paste toggle

set background=dark             " try to use colors that look good on a dark background
if has('termguicolors')
    set termguicolors           " enable GUI colors for the terminal to get truecolor
endif

set noswapfile                  " don't create swapfile for the buffer
" set nobackup                    " don't make a backup before overwriting a file
let &backupdir = s:vimdir . '/tmp'
if !isdirectory(&backupdir)
    call mkdir(&backupdir, 'p', 0755)
    set backup                              " make a backup before overwriting a file
    set backupext=.bak                      " string which is appended to a file name to make the name of the backup file
    set backupskip+=/etc/cron.*/*           " list of file patterns that do not create backup file
endif
if has('persistent_undo')
    let &undodir = s:vimdir . '/undodir'    " list of directory names for undo files, separated with commas
    if !isdirectory(&undodir)
        call mkdir(&undodir, 'p', 0755)
    endif
    set undofile                            " automatically saves undo history to an undo file
    set undolevels=1000                     " maximum number of changes that can be undone
endif

set viminfo='100,:10000,<50,s10,h,!         " viminfo settings
let &viminfo.=',n' . s:vimdir . '/viminfo'  " viminfo file location
set history=10000                           " set how many lines of command history vim has to remember

let &errorfile = s:vimdir . '/error'        " name of the errorfile for the quickfix mode

set dictionary+=/usr/share/dict/words       " files that are used to lookup words for keyword completion commands

set comments=                   " clear default comments value, let the filetype handle it
set include=                    " don't assume I'm editing C; let the filetype set this
set nrformats-=octal            " treat numbers with a leading zero as decimal, not octal
set formatoptions+=j            " delete comment leaders when joining lines, if supported
set signcolumn=number           " display signs in the 'number' column
set shortmess-=S                " helps to avoid all the hit-enter prompts caused by file messages
set laststatus=2                " show status line
set display=lastline            " as much as possible of the last line in a window will be displayed
set scrolloff=1                 " minimal number of screen lines to keep above and below the cursor
set nojoinspaces                " don't insert two spaces after a '.', '?' and '!' with a join command
set matchpairs=(:),{:},[:],《:》,〈:〉,［:］,（:）,「:」,『:』,‘:’,“:” " characters that form pair, % command jumps to the other
set showmatch                   " show the match pairs  can be seen on the screen
set nomodeline                  " don't allow setting options via buffer content
set breakat=                    " line break character ' ', default are ' ^I!@*-+;:,./?'
set linebreak                   " break lines at word boundaries
set visualbell t_vb=            " no beep or flash is wanted

" set list                        " display tabs
" set listchars+=extends:>        " unwrapped text to screen right
" set listchars+=precedes:<       " unwrapped text to screen left
" set listchars+=tab:>-           " tab characters, preserve width
" set listchars+=trail:_          " trailing spaces
" set listchars+=nbsp:+           " non-breaking spaces

set completeopt+=popup,longest,menuone  " list of options for Insert mode completion
set completepopup=border:off            " used for the properties of the info popup when it is created

set diffopt+=vertical,context:3,foldcolumn:0 " option settings for diff mode
if &diffopt =~ 'internal'
    set diffopt+=indent-heuristic,algorithm:patience
endif

set wildmenu                    " show autocomplete for command menu
set wildmode=longest:full,full  " completion mode that is used for the character specified with 'wildchar'
set wildignorecase              " ignore case when completing file names and directories

" Ignore the following extensions on file search and completion
set suffixes=.bak,~,.o,.h,.info,.swp,.obj,.pyc,.pyo,.egg-info,.class
set wildignore=*.o,*.obj,*~,*.exe,*.a,*.pdb,*.lib                               "stuff to ignore when tab completing
set wildignore+=*.so,*.dll,*.swp,*.egg,*.jar,*.class,*.pyc,*.pyo,*.bin,*.dex
set wildignore+=*.zip,*.7z,*.rar,*.gz,*.tar,*.gzip,*.bz2,*.tgz,*.xz
set wildignore+=*DS_Store*,*.ipch
set wildignore+=*.gem
set wildignore+=*.png,*.jpg,*.gif,*.bmp,*.tga,*.pcx,*.ppm,*.img,*.iso
set wildignore+=*.so,*.swp,*.zip,*/.Trash/**,*.pdf,*.dmg,*/.rbenv/**
set wildignore+=*/.nx/**,*.app,*.git,.git
set wildignore+=*.wav,*.mp3,*.ogg,*.pcm
set wildignore+=*.mht,*.suo,*.sdf,*.jnlp
set wildignore+=*.chm,*.epub,*.pdf,*.mobi,*.ttf
set wildignore+=*.mp4,*.avi,*.flv,*.mov,*.mkv,*.swf,*.swc
set wildignore+=*.ppt,*.pptx,*.docx,*.xlt,*.xls,*.xlsx,*.odt,*.wps
set wildignore+=*.msi,*.crx,*.deb,*.vfd,*.apk,*.ipa,*.bin,*.msu
set wildignore+=*.gba,*.sfc,*.078,*.nds,*.smd,*.smc
set wildignore+=*.linux2,*.win32,*.darwin,*.freebsd,*.linux,*.android

" ============> Plugins <============
let s:vimplug = expand(s:vimdir . '/autoload/plug.vim')
if !filereadable(s:vimplug)
    if !executable('curl')
        echoerr 'You have to install curl or first install vim-plug yourself!'
        exe 'q!'
    endif
    echo 'Installing Vim-Plug...'
    echo ''
    silent exe '!curl -fLo ' . s:vimplug . ' --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    autocmd! VimEnter * PlugInstall
endif

call plug#begin(s:vimdir . '/plugged')

Plug 'chriskempson/base16-vim'
Plug 'vim-scripts/ScrollColors'
Plug 'itchyny/lightline.vim'
Plug 'easymotion/vim-easymotion'
Plug 'terryma/vim-multiple-cursors'
Plug 'majutsushi/tagbar'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'mbbill/undotree'
Plug 'jiangmiao/auto-pairs'
Plug 'tpope/vim-surround'
Plug 'ycm-core/youcompleteme', {'do': './install.py --clang-completer --gocode-completer --rust-completer' }
Plug 'dense-analysis/ale'
Plug 'fatih/vim-go', {'do': ':GoUpdateBinaries', 'for': 'go'}
Plug 'rust-lang/rust.vim', {'for': 'rust'}
Plug 'tpope/vim-fugitive'

call plug#end()

" ----> itchyny/lightline.vim
let g:lightline = {
    \ 'enable': {
    \   'statusline': 1,
    \   'tabline': 0
    \ },
    \ 'colorscheme': 'materia',
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \           [ 'bufnum' ],
    \           [ 'gitbranch', 'readonly', 'filename' ] ],
    \   'right': [ [ 'lineinfo' ],
    \            [ 'percent' ],
    \            [ 'linter', 'fileformat', 'fileencoding', 'filetype', 'filesize' ],
    \            [ 'tagbar' ]]
    \ },
    \ 'inactive': {
    \   'left': [ [ 'filename' ]],
    \   'right': [ [ 'lineinfo' ],
    \            [ 'percent' ]]
    \ },
    \ 'component_function': {
    \   'filename': 'LightlineFilename',
    \   'linter': 'LightlineLinter',
    \   'gitbranch': 'LightlineGitBranch',
    \   'filesize': 'LightlineFileSize'
    \ },
    \ 'component': {
    \   'tagbar': '[%{tagbar#currenttagtype("%s", "")}: %{tagbar#currenttag("%s", "", "f")}]'
    \ }
\ }

function! LightlineFilename() abort
    let filename = expand('%:t') !=# '' ? expand('%:t') : '[No Name]'
    let modified = &modified ? ' +' : ''
    return filename . modified
endfunction

function! LightlineFileSize() abort
    let l:bytes = getfsize(@%)
    if l:bytes <= 0
        return '0B'
    endif
    " let l:units = 'BKMGT'
    " let l:fsize = ''
    " let l:idx = 0
    " while l:bytes > 0 && len(l:units) > 0 && l:idx < 5
    "     let l:fsize = l:bytes % 1024 . l:units[l:idx] . l:fsize
    "     let l:idx += 1
    "     let l:bytes /= 1024
    " endwhile
    " return l:fsize
    if (l:bytes >= 1024)
        let l:kbytes = l:bytes / 1024
    endif
    if exists('l:kbytes') && l:kbytes >= 1024
        let l:mbytes = l:kbytes / 1024
    endif
    if exists('l:mbytes') && l:mbytes >= 1024
        let l:gbytes = l:mbytes / 1024
    endif
    if exists('l:gbytes')
        return l:gbytes . 'G'
    elseif exists('l:mbytes')
        return l:mbytes . 'M'
    elseif exists('l:kbytes')
        return l:kbytes . 'K'
    else
        return l:bytes . 'B'
    endif
endfunction

function! LightlineLinter() abort
    let l:counts = ale#statusline#Count(bufnr(''))
    let l:all_errors = l:counts.error + l:counts.style_error
    let l:all_non_errors = l:counts.total - l:all_errors
    return l:counts.total == 0 ? '' : printf(
        \ '%dW %dE',
        \ all_non_errors,
        \ all_errors
    \ )
endfunction

function! LightlineGitBranch() abort
    if &ft !~? 'vimfiler' && exists('*fugitive#head')
        let branch = fugitive#head()
        return branch > 14 ? branch[0:14] . '...' : branch
    endif
    return ''
endfunction

" ----> easymotion/vim-easymotion
let g:EasyMotion_smartcase = 1

" ----> majutsushi/tagbar
nmap <silent> <F8> :TagbarToggle<cr>
let g:tagbar_ctags_bin = 'ctags'
let g:tagbar_autofocus = 1
let g:tagbar_sort = 0
let g:tagbar_width = 40

let g:tagbar_type_make = {
    \ 'ctagstype': 'make',
    \ 'kinds': [
        \ 'm:macros',
        \ 't:targets'
    \ ]
\ }

let g:tagbar_type_markdown = {
    \ 'ctagstype': 'markdown',
    \ 'kinds': [
        \ 'h:headings',
    \ ],
    \ 'sort': 0
\ }

" ----> ctrlpvim/ctrlp.vim
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_show_hidden = 1
let g:ctrlp_switch_buffer = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_match_window = 'bottom,order:ttb'
let g:ctrlp_types = ['fil', 'mru', 'buf']
let g:ctrlp_root_markers = ['.svn', '.git', '.projections.json', '.travis.yml', 'Cargo.toml', 'go.mod']
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\v[\/]\.(git|hg|svn)$',
    \ 'file': '\v\.(exe|so|dll)$',
    \ 'link': 'some_bad_symbolic_links',
\ }
if executable('rg')
    set grepprg=rg\ --color=never
    let g:ctrlp_user_command = 'rg %s --files --color=never --glob ""'
    let g:ctrlp_use_caching = 0
endif

" ----> mbbill/undotree
nnoremap <F5> :UndotreeToggle<cr>


" ----> ycm-core/youcompleteme
nmap <leader>yd :YcmDiags<cr>
augroup YCM
    autocmd!
    autocmd FileType c,cpp                                           nnoremap <leader>yi :YcmCompleter GoToInclude<cr>
    autocmd FileType c,cpp,go,java,javascript,python,rust,typescript nnoremap <leader>yl :YcmCompleter GoToDeclaration<cr>
    autocmd FileType c,cpp,go,java,javascript,python,rust,typescript nnoremap <leader>ye :YcmCompleter GoToDefinition<cr>
    autocmd FileType c,cpp,go,java,javascript,python,rust,typescript nnoremap <leader>yo :YcmCompleter GoTo<cr>
    autocmd FileType java,javascript,python,typescript               nnoremap <leader>yr :YcmCompleter GoToReferences<cr>
    autocmd FileType javascript,typescript                           nnoremap <leader>yp :YcmCompleter GoToType<cr>
    autocmd FileType c,cpp,java,javascript,typescript                nnoremap <leader>yg :YcmCompleter GetType<cr>
    autocmd FileType c,cpp                                           nnoremap <leader>ya :YcmCompleter GetParent<cr>
    autocmd FileType c,cpp,java,javascript,python,rust,typescript    nnoremap <leader>yc :YcmCompleter GetDoc<cr>
    autocmd FileType c,cpp,java,javascript,typescript                nnoremap <leader>yf :YcmCompleter FixIt<cr>
augroup END
let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'    "default ycm conf location
let g:ycm_error_symbol = '>>'
let g:ycm_warning_symbol = '--'
let g:ycm_confirm_extra_conf = 0    "no annoying tips on vim starting
let g:ycm_show_diagnostics_ui = 0
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_complete_in_comments = 1
let g:ycm_key_invoke_completion = '<c-z>'
set completeopt=menu,menuone
noremap <c-z> <NOP>
let g:ycm_use_ultisnips_completer = 0
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_semantic_triggers = {'*': ['re![.:>\-\w]{2}']}

" ----> dense-analysis/ale
let g:ale_disable_lsp = 1
let g:ale_maximum_file_size = 2 * 1024 * 1024
let g:ale_linters_explicit = 1
let g:ale_lint_on_enter = 0
let g:ale_lint_on_filetype_changed = 0
let g:ale_lint_on_text_changed = 0
let g:ale_lint_on_insert_leave = 1
let g:ale_lint_on_save = 1
let g:ale_linters = {
    \ 'c': ['gcc'],
    \ 'cpp': ['gcc'],
    \ 'go': ['golint', 'go vet'],
    \ 'java': ['javac'],
    \ 'lua': ['luac'],
    \ 'rust': ['cargo'],
    \ 'sh': ['shell', 'shellcheck']
\ }
let g:ale_c_gcc_options = '-Wall -O2 -std=c99'
let g:ale_cpp_gcc_options = '-Wall -O2 -std=c++14'
let g:ale_linter_aliases = {
    \ 'Dockerfile': 'dockerfile',
    \ 'vimwiki': 'markdown',
    \ 'zsh': 'sh'
\ }
let g:ale_fixers = {
    \ '*': ['remove_trailing_lines', 'trim_whitespace'],
    \ 'go': ['goimports'],
    \ 'python': ['yapf']
\}
let g:ale_fix_on_save = 1
let g:ale_sign_error = '>>'
let g:ale_sign_warning = '--'
let g:ale_sign_info = '~~'
let g:ale_echo_msg_format = '%severity%: [%linter%] %s'
let g:ale_loclist_msg_format = '[%linter%] %s'
let g:ale_list_window_size = 5
let g:ale_open_list = 'on_save'

nmap <silent> <c-k> <Plug>(ale_previous_wrap)
nmap <silent> <c-j> <Plug>(ale_next_wrap)

highlight clear ALEErrorSign
highlight clear ALEWarningSign
highlight clear ALEInfoSign
highlight clear ALEStyleErrorSign
highlight clear ALEStyleWarningSign

" ----> fatih/vim-go
let g:go_code_completion_enabled = 0
let g:go_def_mapping_enabled = 0
let g:go_autodetect_gopath = 1
let g:go_fmt_autosave = 0
let g:go_fmt_command = 'goimports'
let g:go_list_type = "quickfix"
let g:go_addtags_transform = 'camelcase'
let g:go_highlight_extra_types = 1
let g:go_highlight_functions = 1
let g:go_highlight_function_calls = 1
let g:go_highlight_function_parameters = 1
let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_generate_tags = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_format_strings = 1

augroup Go
    autocmd!
    autocmd FileType go nmap <c-g> :GoDeclsDir<cr>
    autocmd FileType go imap <c-g> <esc>:<c-u>GoDeclsDir<cr>
    autocmd FileType go nmap <leader>gb :<c-u>call <SID>build_go_files()<cr>
    autocmd FileType go nmap <leader>gt <Plug>(go-test)
    autocmd FileType go nmap <leader>gf <Plug>(go-test-func)
    autocmd FileType go nmap <leader>gr <Plug>(go-run)
    autocmd FileType go nmap <leader>gh <Plug>(go-doc)
    autocmd FileType go nmap <leader>gc <Plug>(go-coverage-toggle)
    autocmd FileType go nmap <leader>gi <Plug>(go-info)
    autocmd FileType go nmap <leader>gd <Plug>(go-def-split)
    autocmd FileType go nmap <leader>gm <Plug>(go-rename)
    autocmd FileType go nmap <leader>ge <Plug>(go-iferr)
    autocmd Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
    autocmd Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
    autocmd Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
    autocmd Filetype go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')
augroup END

" build_go_files is a custom function that builds or compiles the test file.
" It calls :GoBuild if its a Go file, or :GoTestCompile if it's a test file
function! s:build_go_files() abort
    let l:file = expand('%')
    if l:file =~# '^\f\+_test\.go$'
        call go#test#Test(0, 1)
    elseif l:file =~# '^\f\+\.go$'
        call go#cmd#Build(0)
    endif
endfunction

" ----> rust-lang/rust.vim
let g:rustfmt_autosave = 1

" ============> Custom <============

" ----> Color
silent! colorscheme base16-materia

" ----> Highlights
" Highlight some special strings
highlight ToDo cterm=bold term=bold ctermbg=yellow ctermfg=black
match ToDo /\(TODO\)/
augroup hilightSpecialStrings
    autocmd!
    autocmd WinEnter * match ToDo /\(TODO\)/
augroup END

" Highlight WhiteSpaceEOL ctermbg=darkgreen guibg=lightgreen
" match WhiteSpaceEOL /\s$/
" augroup hilightSpecialStrings
"     autocmd WinEnter * match WhiteSpaceEOL /\s$/
" augroup END

" Some custom highlights
highlight Normal guibg=black ctermbg=black
highlight LineNr guibg=black ctermbg=black
highlight SignColumn guibg=black ctermbg=black

" ----> Keyboard
let mapleader = ','     " set vim map leader
let g:mapleader = ','

nnoremap <silent> <leader>n :nohlsearch<cr> " turn off search highlight
nnoremap <leader>sh :sh<cr>                 " hold vim and run a shell at this directory, exit will return vim

nnoremap <leader>tc :tabclose<cr>           " close tab
nnoremap <leader>tn :tabnext<cr>            " go to next tab
nnoremap <leader>tp :tabprevious<cr>        " go to previous tab
nnoremap <leader>te :tabnew<cr>             " create new tab

nnoremap <leader>bp :bprevious<cr>          " go to previous buffer
nnoremap <leader>bn :bnext<cr>              " go to next buffer
nnoremap <leader>bd :bdelete<cr>            " close the current buffer
nnoremap <leader>bl :buffers<cr>            " list buffers
nnoremap <leader>bg :buffer                 " go to given buffer number

nnoremap <F2> :setlocal spell! spelllang=en_us<cr>   " set spell shortcut

cnoreabbrev W! w!   " easy exit vim
cnoreabbrev Q! q!
cnoreabbrev Qall! qall!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qall qall

nnoremap B ^        " move to beginning/end of line
nnoremap E $
nnoremap $ <nop>    " $/^ doesn't do anything
nnoremap ^ <nop>

nnoremap gV `[v`]   " highlight last inserted text

" Vmap for maintain Visual Mode after shifting > and <
vmap < <gv
vmap > >gv

noremap gh <c-w>h
noremap gk <c-w>k
noremap gl <c-w>l
noremap gj <c-w>j
" noremap F gf

" Search will center on the line it's found in
nnoremap n nzzzv
nnoremap N Nzzzv

" Move visual block
vnoremap J :m '>+1<cr>gv=gv
vnoremap K :m '<-2<cr>gv=gv

" Move vertically by visual line
noremap <silent> <expr> j (v:count == 0 ? 'gj' : 'j')
noremap <silent> <expr> k (v:count == 0 ? 'gk' : 'k')

nnoremap <leader>tm :terminal<cr><c-w>L

" Hex read
nmap <leader>hr :%!xxd<cr> :set filetype=xxd<cr>
" Hex write
nmap <leader>hw :%!xxd -r<cr> :set binary<cr> :set filetype=<cr>

" Map w!! to write file with sudo
cmap w!! w !sudo tee % >/dev/null

" Toggle displaying non-printable characters
nnoremap <leader>ls :set list!<cr>

" Toggle soft-wrap
nnoremap <leader>wr :set wrap! wrap?<cr>

" ----> Tricks
" Switch to working directory of the open file
autocmd! BufEnter * lcd %:p:h

" Trim trailing whitespace on write
autocmd! BufWritePre * :%s/\s\+$//e

" Terminal setting
if has('terminal') && exists(':terminal') == 2
    if exists('##TerminalOpen')
        autocmd! TerminalOpen * setlocal nonumber signcolumn=no
    endif
endif

" Remember cursor position
autocmd! BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

" Close the quickfix or locationlist window when exiting
autocmd! QuitPre * if empty(&buftype) | cclose | lclose | endif

" InsertLeave *   set imdisable   " cancle IME on normal mode
" InsertEnter *   set noimdisable

" ----> Netrw
let g:netrw_banner = 1
let g:netrw_liststyle = 3
let g:netrw_browse_split = 4
let g:netrw_altv = 1
let g:netrw_winsize = 25
let g:netrw_list_hide = &wildignore
function! NetrwToggle() abort
    let i = bufnr("$")
    let wasOpen = 0
    while (i >= 1)
        if (getbufvar(i, "&filetype") == "netrw")
            silent exe "bwipeout " . i
            let wasOpen = 1
        endif
        let i-=1
    endwhile
    if !wasOpen
        silent Lexplore
    endif
endfunction
noremap <silent> <F3> :call NetrwToggle()<cr>

" ----> Zen mode
let s:zen_mode=0
function! ZenModeToggle() abort
    if s:zen_mode==0
        let s:zen_mode=1
        set noshowmode
        set noruler
        set laststatus=0
        set noshowcmd
        set nonumber
        syntax off
        highlight Normal guifg=LightGrey ctermfg=LightGrey guibg=black ctermbg=black
    else
        let s:zen_mode=0
        set showmode
        set ruler
        set laststatus=2
        set showcmd
        set number
        highlight clear Normal
        syntax on
    endif
endfunction
nnoremap <silent> <leader>z :call ZenModeToggle()<cr>

" ----> View changes after the last save
function! s:DiffWithSaved() abort
    let filetype=&ft
    diffthis
    vnew | r # | normal! 1Gdd
    diffthis
    exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
    exe "normal! ]c"
endfunction
command! DiffSaved call s:DiffWithSaved()
nnoremap <leader>d :DiffSaved<cr>

" ----> Toggle Quickfix / LocationList window
function! QuickfixToggle() abort
    if len(filter(getwininfo(), 'v:val.quickfix'))
        cclose
    else
        copen 6
    endif
endfunction
nnoremap <leader>q :call QuickfixToggle()<cr>

function! LocationToggle() abort
    if len(filter(getwininfo(), 'v:val.loclist'))
        lclose
    else
        lopen 6
    endif
endfunction
nnoremap <leader>l :call LocationToggle()<cr>
